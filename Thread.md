## 线程和线程安全
1. 什么是进程：电脑中会有很多单独运行的程序，每个程序有一个独立的进程，而进程之间是相互独立存在的。（比如QQ、电脑管家等等）。
2. 线程：进程中最小的执行单位就是线程，并且一个进程中至少有一个线程。串行：其实就是相对于单线程来执行多个任务来说的，例如下载文件来说：当我们下载多个文件时，在串行中它是按照一定的顺序去进行下载的，也就是说，必须要等到下载完a之后才能开始下载b,他们在时间上是不可能发生重叠的。并行：下载多个文件，开启条线程，多个文件之间同时下载，这里是严格意义上的，在同一时刻发生的，并行在时间上是重叠的。一个进程同时产生了多个线程。

### 线程安全

1. 线程安全：当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说是这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为。则说是这个类是线程安全的。
### 多线程之间的几把锁
1. 互斥锁：用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。

	```
    头文件：#include<pthread.h>
    类型：pthread_mutex_t
    函数：
    //动态方式创建锁，相当于new动态创建一个对象
    pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr);
    //释放互斥锁，相当于delete
    pthread_mutex_destroy(pthread_mutex_t *mutex);
    //以静态方式创建锁
    pthread_mutex_t     mutex=PTHREAD_MUTEX_INITALIZER;
    ```
    
    ```
    //以阻塞方式运行的。如果之前mutex被加锁了，那么程序会阻塞在这里.
    pthread_mutex_lock(pthread_mutex_t *mutex);   
pthread_mutex_unlock(pthread_mutex_t *mutex);
//会尝试对mutex加锁。如果mutex之前已经被锁定，返回非0；如果mutex没有被锁定，则函数返回并锁定mutex
//该函数是以非阻塞方式运行了。也就是说如果mutex之前已经被锁定，函数会返回非0，程序继续往下执行。
int pthread_mutex_trylock(pthread_mutex_t * mutex);
    ```



















































